# Долгосрочная память (Long-Term Memory)

В отличие от стандартной краткосрочной памяти, которая хранит только историю текущего диалога, система **PyAgentX** наделена **долгосрочной памятью**. Это позволяет агентам накапливать знания между сессиями, "учиться" на прошлом опыте и использовать его в будущих задачах.

### Реализация

Механизм долгосрочной памяти реализован с помощью двух ключевых компонентов:

1.  **Менеджер памяти (`app/memory/memory_manager.py`)**: Это специализированный класс, который инкапсулирует всю логику работы с базой данных памяти. Он использует простую и надежную базу данных **SQLite** для хранения фактов. Каждая запись в базе представляет собой отдельный "факт" или "воспоминание". Менеджер предоставляет простые методы для сохранения новых фактов и поиска релевантных старых фактов.

2.  **Инструмент для сохранения памяти (`save_memory_tool`)**: Мы не заставляем агента сохранять все подряд. Вместо этого мы предоставляем ему специальный инструмент. Агент в ходе своей работы (`ReAct-цикла`) может сам принять решение, что какая-то часть информации (например, вывод успешной команды, важный факт из поиска или ключевое решение в задаче) является достаточно ценной для сохранения на будущее. В этом случае он вызывает `save_memory_tool` и передает ему текст, который необходимо запомнить.

### Как это работает?

1.  **Сохранение**: Во время выполнения задачи агент сталкивается с важной информацией. В своей "мысли" он решает: "Этот факт важен, его нужно сохранить". Затем он вызывает инструмент `save_memory_tool` с этой информацией. Менеджер памяти записывает этот факт в базу данных SQLite.

2.  **Извлечение**: В начале каждой новой задачи Оркестратор автоматически делает запрос к долгосрочной памяти. Он ищет в базе факты, которые семантически близки к новой поставленной цели.

3.  **Использование**: Найденные "воспоминания" добавляются в системный промпт агента, который будет выполнять задачу. Таким образом, еще до начала работы агент получает релевантный контекст из прошлого опыта, что помогает ему принимать более информированные и эффективные решения.

Этот подход позволяет системе не решать одну и ту же проблему дважды и со временем становиться все более "опытной".

[Вернуться к README](../README.md) 