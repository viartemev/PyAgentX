"""
Модуль для декомпозиции высокоуровневой задачи на конкретные подзадачи.
"""
import json
import logging
from typing import List, Optional, Dict, Any
from openai import OpenAI

DECOMPOSER_PROMPT = """
Твоя задача - разбить высокоуровневую цель на детальный, последовательный план для AI-агента.
Ответ должен быть ТОЛЬКО JSON-массивом строк без какого-либо другого текста или объяснений.

# Доступные Инструменты Агента:
Агент имеет доступ к следующим функциям, которые он может использовать для выполнения шагов:
- `list_files_tool(path: str)`: Показывает содержимое директории.
- `read_file_tool(path: str)`: Читает содержимое файла.
- `edit_file_tool(path: str, mode: str, ...)`: Редактирует файл. Режимы: 'append' (добавить в конец), 'replace' (заменить фрагмент), 'overwrite' (перезаписать).
- `delete_file_tool(path: str)`: Удаляет файл.

# Правила Создания Плана:
1.  **Конкретика**: Каждый шаг должен быть одной конкретной, осмысленной операцией. Думай о том, как бы ты сам решал эту задачу, используя доступные инструменты.
2.  **Эффективность**: Не создавай лишних шагов. Например, не нужно отдельно "проверять существование файла", если следующий шаг - его чтение. Инструмент `read_file_tool` сам сообщит об ошибке, если файла нет.
3.  **Никаких фиктивных шагов**: Не создавай шаги, для которых нет инструментов. Например, "закрыть файл", "проверить синтаксис" или "запустить тесты" - это плохие шаги, так как у агента нет для них инструментов.
4.  **Целостность**: Думай о всем процессе. Если один шаг генерирует код, следующий шаг должен использовать этот код (например, сохранить его в файл).

# Пример:
### Цель:
"Проанализируй файл `main.py`, предложи улучшение и запиши новую версию в `main_v2.py`."

### Хороший план (твой результат должен быть в таком формате):
[
  "Прочитать содержимое файла `main.py` для анализа.",
  "Проанализировать прочитанный код и сгенерировать новую, улучшенную версию кода.",
  "Записать сгенерированный улучшенный код в новый файл `main_v2.py`."
]


# Твоя Задача:
### Цель:
"{main_goal}"

### План (только JSON):
"""

class TaskDecomposer:
    """
    Декомпозирует основную задачу на список подзадач с помощью LLM.
    """
    def __init__(self, api_key: str, model: str = "gpt-4-turbo"):
        self.client = OpenAI(api_key=api_key)
        self.model = model

    def _parse_llm_response(self, content: Optional[str]) -> List[str]:
        """Более гибко парсит ответ от LLM."""
        if not content:
            logging.warning("LLM вернул пустой ответ при декомпозиции.")
            return []
        
        try:
            # Пытаемся загрузить как полноценный JSON
            parsed_json = json.loads(content)
            
            if isinstance(parsed_json, list):
                return [str(item) for item in parsed_json]
            
            # Если это словарь, ищем в нем ключ, содержащий список
            if isinstance(parsed_json, dict):
                for key, value in parsed_json.items():
                    if isinstance(value, list):
                        logging.info("Найден план в ключе '%s'", key)
                        return [str(item) for item in value]
            
            logging.warning("Ответ LLM не является списком или не содержит списка. Ответ: %s", content)
            return []

        except json.JSONDecodeError:
            # Иногда LLM возвращает голый список без кавычек, пробуем его "починить"
            logging.warning("Не удалось распарсить JSON. Ответ: %s", content)
            # Это очень упрощенная попытка извлечь строки, может не сработать всегда
            cleaned_content = content.strip().replace("`", "")
            if cleaned_content.startswith('[') and cleaned_content.endswith(']'):
                try:
                    return json.loads(cleaned_content)
                except json.JSONDecodeError:
                    pass
            logging.error("Не удалось извлечь план из ответа LLM.")
            return []

    def generate_plan(self, goal: str) -> List[Dict[str, Any]]:
        """
        Генерирует пошаговый план для достижения цели, назначая исполнителей.
        # ... (остальной docstring без изменений)
        """
        # Обновленный промпт с описанием ролей и требованием назначить исполнителя
        system_prompt = """
Ты — элитный AI-планировщик, специализирующийся на декомпозиции сложных IT-задач для команды AI-агентов.
Твоя задача — разбить высокоуровневую цель на детальный, последовательный план в формате JSON.

# СТРУКТУРА ПРОЕКТА (КРИТИЧЕСКИ ВАЖНО):
-   `app/`: Вся логика приложения находится здесь.
    -   `app/agents/`: Код самих агентов.
    -   `app/agents/tools.py`: **Файл с инструментами, которые используют агенты.**
    -   `app/orchestration/`: Код планировщика и оркестратора.
-   `tests/`: Все тесты находятся здесь.
    -   `tests/test_tools.py`: **Тесты для инструментов из `app/agents/tools.py`**

# ДОСТУПНАЯ КОМАНДА АГЕНТОВ:
1.  **CodingAgent**:
    -   **Специализация**: Написание, чтение и модификация кода.
    -   **Инструменты**: `list_files`, `read_file`, `edit_file`.
2.  **TestingAgent**:
    -   **Специализация**: Тестирование кода.
    -   **Инструменты**: `read_file`, `run_tests`.
3.  **ReviewerAgent**:
    -   **Специализация**: Проверка качества кода, поиск багов и несоответствий.
    -   **Инструменты**: `read_file`.
4.  **EvaluatorAgent**:
    -   **Специализация**: Анализ ошибок и составление баг-репортов.
    -   **Инструменты**: `read_file`.
    -   **ВАЖНО**: Этот агент используется Оркестратором автоматически при провале тестов. Тебе не нужно назначать ему задачи в первоначальном плане.
5.  **DefaultAgent**:
    -   **Специализация**: Общие задачи и анализ.
    -   **Инструменты**: `list_files`, `read_file`.

# ПРАВИЛА СОСТАВЛЕНИЯ ПЛАНА:
1.  **Code Review для ВСЕГО кода**: Сразу после КАЖДОГО шага, в котором `CodingAgent` пишет или изменяет любой код (будь то основной код, тесты, документация и т.д.), ОБЯЗАТЕЛЬНО должен следовать шаг "Провести Code Review", назначенный на `ReviewerAgent`.
2.  **Полные пути**: ВСЕГДА используй полные относительные пути от корня проекта для любых файлов. Например: `app/agents/tools.py`, `tests/test_tools.py`.
3.  **Конкретика**: Формулируй задачи максимально конкретно. Вместо "написать функцию", пиши "добавить функцию X в файл Y".
4.  **Логика прежде тестов**: План должен сначала содержать шаг для написания или изменения **полной логики** функции, и только потом — шаг для написания тестов.
5.  **Сфокусированное тестирование**: Шаг для тестирования должен указывать конкретный файл с тестами. В `description` задачи ОБЯЗАТЕЛЬНО включи пример вызова инструмента, например: `Используя 'run_tests', вызови его так: run_tests_tool({'path': 'tests/test_tools.py'})`.
6.  **Назначение**: Для каждого шага укажи `assignee` (`CodingAgent`, `TestingAgent`, `DefaultAgent`).
7.  **Формат**: Вывод должен быть СТРОГО в формате JSON-массива объектов.

# ПРИМЕР:

**Цель**: "Добавить в `tools.py` функцию `multiply(a, b)` и покрыть ее тестами."

**Результат (JSON):**
```json
[
    {
        "step": 1,
        "assignee": "CodingAgent",
        "task": "Добавить функцию 'multiply_tool' в файл 'app/agents/tools.py'.",
        "description": "Нужно открыть файл 'app/agents/tools.py' и добавить в него новую Python-функцию 'multiply', которая принимает два числовых аргумента и возвращает их произведение. Использовать режим 'append'."
    },
    {
        "step": 2,
        "assignee": "ReviewerAgent",
        "task": "Провести Code Review для функции 'multiply_tool' в 'app/agents/tools.py'.",
        "description": "Проверить код на соответствие стандартам качества."
    },
    {
        "step": 3,
        "assignee": "CodingAgent",
        "task": "Создать файл 'tests/test_tools.py' с тестами для 'multiply_tool'.",
        "description": "В файле 'tests/test_tools.py' написать тест 'test_multiply' с использованием pytest, который проверяет корректность работы функции 'multiply'."
    },
    {
        "step": 4,
        "assignee": "ReviewerAgent",
        "task": "Провести Code Review для файла 'tests/test_tools.py'.",
        "description": "Проверить код тестов на полноту, корректность и стиль."
    },
    {
        "step": 5,
        "assignee": "TestingAgent",
        "task": "Запустить тесты для файла 'tests/test_tools.py'.",
        "description": "Используя инструмент 'run_tests', вызови его с аргументом {'path': 'tests/test_tools.py'} для проверки выполненной работы."
    }
]
```
"""
        user_prompt = f"Моя цель: \"{goal}\". Пожалуйста, составь план."

        try:
            response = self.client.chat.completions.create(
                model=self.model,
                messages=[{"role": "system", "content": system_prompt}, {"role": "user", "content": user_prompt}],
                # response_format убираем, чтобы дать модели больше гибкости
            )
            
            plan_str = response.choices[0].message.content
            
            # Улучшенная очистка ответа модели
            # Иногда модель оборачивает JSON в ```json ... ```
            if plan_str.strip().startswith("```json"):
                plan_str = plan_str.strip()[7:-3].strip()

            plan = json.loads(plan_str)
            
            # Валидация, что каждый шаг содержит ключ 'assignee'
            for step in plan:
                if 'assignee' not in step:
                    raise ValueError(f"Шаг {step.get('step')} в плане не содержит обязательное поле 'assignee'")

            return plan

        except Exception as e:
            logging.error("Произошла ошибка при декомпозиции задачи: %s", e, exc_info=True)
            return [] 